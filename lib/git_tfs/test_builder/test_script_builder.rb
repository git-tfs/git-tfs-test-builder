require "erb"
require "tilt"

module GitTfs
  module TestBuilder
    class TestScriptBuilder
      def initialize(options)
        @name = options.fetch(:name)
      end

      def <<(changeset)
        changesets[changeset.number.to_i] = changeset
      end

      def write(io)
        io.write render(template)
      end

      private

      def render(template, locals = {})
        tilt = Tilt::ERBTemplate.new("(inline)") { template }
        tilt.render(self, locals)
      end

      def render_each(template, varname, collection)
        collection.map { |item| render(template, varname => item) }.join("")
      end

      def class_name
        @name # todo - make it a valid C# class name.
      end

      def changesets
        @changesets ||= {}
      end

      def sorted_changesets
        changesets.keys.sort.map { |number| changesets[number] }
      end

      def template
        <<END_TEMPLATE
// Generated by git-tfs-test-builder
using Sep.Git.Tfs.Test.Integration;

namespace Sep.Git.Tfs.Test.Fixtures
{
    static class <%= class_name %>
    {
        public static void Prepare(IntegrationHelper.FakeHistoryBuilder r)
        {
<%= render_each changeset_template, :changeset, sorted_changesets %>
        }

        private static Stream OpenItemContent(string itemContentHash)
        {
            if (itemContentHash == null) return null;
            return typeof(<%= class_name %>).Assembly.GetManifestResourceStream("Sep.Git.Tfs.Test.Fixtures.<%= class_name %>." + itemContentHash);
        }
    }
}
END_TEMPLATE
      end

      def changeset_template
        <<END_TEMPLATE
            r.Changeset(<%=cs changeset.number %>, <%=cs changeset.comment %>, DateTime.Parse(<%=cs changeset.date %>))
<%= render_each change_template, :change, changeset.changes %>;
<%# changeset.raw %>
END_TEMPLATE
      end

      def change_template
        <<END_TEMPLATE
                .Change(<%=enum "TfsChangeType", change.change_types %>, <%= enum "TfsItemType", change.item_type %>, <%=cs change.item_path %>, () => OpenItemContent(<%=cs change.item_hex_hash %>), <%=cs change.item_id %>)
END_TEMPLATE
      end

      # Format a value as a C# literal.
      def cs(value)
        case value
        when nil
          "null"
        when String, Fixnum
          value.inspect # I think this'll work for all the values we have to work with.
        else
          raise "Can't make #{value.class.name} into a C# value!"
        end
      end

      def enum(enum_type, *value_names)
        value_names.flatten.compact.map { |v| "#{enum_type}.#{v}" }.join(" | ")
      end
    end
  end
end
